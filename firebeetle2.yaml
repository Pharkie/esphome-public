# This is for the Firebeetle 2 ESP32-C6 with the Waveshare 2.9" black and white ePaper.

substitutions:
  device_name: "firebeetle2"
  friendly_name: "Firebeetle2 ESP32-C6 2.9in ePaper"
  sleep_time: 60min
  # Will stay awake less than this, since device put to sleep once screen is updated
  # Be wary of setting this lower since it can interrupt other processes inc on_boot
  wake_time: 60s 
  screen_update_time: 5s

logger:
  level: DEBUG # Set logging level (DEBUG for verbose output)
  baud_rate: 115200  # Set the baud rate for logging output

external_components:
  - source:
      type: git
      url: https://github.com/lboue/esphome
      ref: adc_oneshot
    components: [ adc ]
    refresh: 0s # Do not update automatically

esphome:
  name: ${device_name}

  # Boot runs on startup and on wake from deep sleep
  # Sequence: start up, get data, update screen, go back to sleep. Completes in 7 seconds.
  on_boot:
    priority: -100.0 # -100 waits till boot of everything else is finished
    then:
      - logger.log: "Booted. Waiting until sensors updated."
      # Display "Awaiting data..." if Bitcoin price not available
      - if:
          condition:
            lambda: 'return isnan(id(bitcoin_current_price).state);'
          then:
            - script.execute: update_screen # Display "Awaiting data..." while we get data
            - logger.log: "Starting delay 1 for screen refresh."
            - delay: ${screen_update_time} # Wait for screen refresh
            - logger.log: "Delay 1 for screen refresh completed."
          else:
            - logger.log: "Bitcoin price is not NaN, skipping 'Awaiting data' call."
      - wait_until:
          condition:
            and:
              - wifi.connected
              - api.connected
              - time.has_time
              - lambda: 'return id(data_updated) == true;'
          timeout: 30s
      - if:
          condition:
            lambda: 'return id(data_updated) == true;'
          then:
            - logger.log:
                format: "Boot: data updated successfully."
                level: INFO
          else:
            - logger.log:
                format: "Boot: timed out waiting for data update."
                level: WARN
      - script.execute: update_screen # Now update the screen to show the data received
      - logger.log: "Starting delay 2 for screen refresh."
      - delay: ${screen_update_time} # Wait for screen refresh
      - logger.log: "Delay 2 for screen refresh completed."
      - script.execute: start_deep_sleep # Go to sleep

safe_mode:
  boot_is_good_after: 5s  # Reduce the time to consider boot successful
  num_attempts: 5  # Number of failed boot attempts before entering safe mode
  reboot_timeout: 1min  # Duration to remain in safe mode before rebooting
  on_safe_mode:
    then:
      - logger.log: "Entering safe mode due to repeated boot failures"

esp32:
  board: esp32-c6-devkitc-1
  flash_size: 4MB
  variant: esp32c6
  framework:
    type: esp-idf
    version: "5.3.1"
    platform_version: 6.9.0
    sdkconfig_options:
      CONFIG_ESPTOOLPY_FLASHSIZE_4MB: y

# Define a deep sleep control object
deep_sleep:
  id: deep_sleep_control
  # run_duration: ${wake_time} # Overridden by the timings in on_boot, so best not define.
  # sleep_duration: ${sleep_time} # Overridden by start_deep_sleep >> sleep_duration, so best not define.

# Enable Home Assistant API
api:
  encryption:
    key: !secret firebeetle2_api_encryption_key

ota:
  platform: esphome
  password: !secret firebeetle2_ota_password

button:
  - platform: safe_mode
    name: "${device_name} Safe Mode: only logging, wifi and OTA"
  - platform: shutdown
    name: "${device_name} Shutdown"
  - platform: restart
    name: "${device_name} Restart"
  - platform: template
    name: "${device_name} Refresh Screen"
    entity_category: config
    on_press:
      - script.execute: update_screen

captive_portal:

binary_sensor:
  # Import the input_boolean helper entity from Home Assistant
  - platform: homeassistant
    id: enable_deep_sleep
    entity_id: input_boolean.firebeetle_enable_sleep
    on_state:
      then:
         - script.execute: start_deep_sleep  

  - platform: status
    name: ${friendly_name} Status 

# Global variable to track if the display needs to be refreshed: thanks @paviro.
globals:
  - id: data_updated
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: bitcoin_price_formatted
    type: std::string
    restore_value: no
    initial_value: '""'

script:
  - id: update_sensors
    # Since sensors are set to update: never
    mode: queued
    then:
      # component.update publishes the sensor to HA
      - component.update: display_refreshes 
      - component.update: battery_voltage # Calls component.update: battery_percentage

  - id: update_screen
    mode: queued
    then:
      - logger.log: "Executing update_screen script"
      - script.execute: update_sensors
      - wait_until:
          condition:
            and:
              - lambda: 'return !isnan(id(display_refreshes).state);'
              - lambda: 'return !isnan(id(battery_voltage).state);'
              - lambda: 'return !isnan(id(battery_percentage).state);'
          timeout: 5s
      - lambda: |-
          id(data_updated) = false;
          id(display_refreshes).publish_state(id(display_refreshes).state + 1);
      - component.update: adam_epaper1
      - logger.log: "Screen updated. Refresh count, battery voltage, and percentage sensors published."
  - id: start_deep_sleep
    mode: queued
    then:
      - logger.log: "Script 'start_deep_sleep' called"
      - if:
          condition:
            binary_sensor.is_on: enable_deep_sleep
          then:
            - logger.log: "Deep Sleep Enabled: going to sleep"
            - deep_sleep.enter:
                id: deep_sleep_control
                sleep_duration: ${sleep_time}         
          else:
            - logger.log: "Deep Sleep Disabled: staying awake"
            - deep_sleep.prevent: deep_sleep_control

time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: GMT0BST,M3.5.0/1,M10.5.0
    update_interval: 60min
    on_time_sync:
      - then:
          - logger.log: Time set
    on_time:
      # Update screen every X minutes >> superseded by sleep cycle and boot that updates screen.
      # Device won't stay awake long enough for a time-based refresh to occur.
      # But leave here in case I disable sleep and want to see display refresh.
      - seconds: 0
        minutes: /1
        then:
          - script.execute: update_screen
      # If the device boots and the hour is "23", it will sleep until 06:00 the next day.
      # Without "minutes: 0", this condition will match any minute within 23:00-23:59,
      # not just 23:00 exactly. With a 60-minute sleep time, the device should wake up once,
      # during the hour of 23, then sleep until 06:00 the next day.
      - hours: 23 
        then:
          - logger.log: "Going for a sleep during the night. Good night!"
          - deep_sleep.enter:
              id: deep_sleep_control
              until: "6:00:00"
              time_id: homeassistant_time

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true

sensor:
  # Bitcoin Current Price
  - platform: homeassistant
    name: "${device_name} Bitcoin Current Price from HA"
    entity_id: sensor.bitcoin_current_price
    id: bitcoin_current_price
    on_value:
      then:
        # Format as $xxx,xxx (no decimal places)
        - lambda: |- 
            float price = id(bitcoin_current_price).state;
            int price_int = static_cast<int>(price);
            char price_str[15];
            snprintf(price_str, sizeof(price_str), "%d", price_int);
            std::string price_formatted = price_str;
            int insert_position = price_formatted.length() - 3;
            while (insert_position > 0) {
              price_formatted.insert(insert_position, ",");
              insert_position -= 3;
            }
            id(bitcoin_price_formatted) = price_formatted;
            
            // Only this data matters enough to flag for screen update
            id(data_updated) = true;

  # Bitcoin All time high price
  - platform: homeassistant
    name: "${device_name} Received Bitcoin All Time High"
    entity_id: sensor.bitcoin_all_time_high
    id: bitcoin_all_time_high

  # Battery voltage
  - platform: adc
    name: "${friendly_name} Battery Voltage"
    id: battery_voltage
    pin: GPIO0
    accuracy_decimals: 2
    update_interval: never # Only updated by script
    filters:
      - multiply: 2.0
    on_value:
      then:
        - component.update: battery_percentage

  # Battery percentage
  - platform: template
    name: "${friendly_name} Battery"
    id: battery_percentage
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: never # Only updated by script
    device_class: battery
    lambda: |-
      float voltage = id(battery_voltage).state;
      int percentage = (voltage - 3.3) / (4.1 - 3.3) * 100;
      if (percentage < 0) {
        percentage = 0;
      } else if (percentage > 100) {
        percentage = 100;
      }
      return percentage;

  # Display last update time
  - platform: template
    name: "${device_name} Display Last Update"
    id: display_last_update
    device_class: timestamp
    entity_category: "diagnostic"
    update_interval: never # Only updated by script

  # Display refreshes count
  - platform: template
    name: "${device_name} Display Refreshes"
    id: display_refreshes
    accuracy_decimals: 0
    unit_of_measurement: "Refreshes"
    state_class: "total_increasing"
    entity_category: "diagnostic"
    update_interval: never # Only updated by script
    lambda: |-
      if (isnan(id(display_refreshes).state)) {
        return 1;
      }
      return id(display_refreshes).state;

  # WiFi signal strength
  - platform: wifi_signal
    name: "${device_name} WiFi Signal Strength"
    id: wifisignal
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
    update_interval: 60min

# Enable HTTP Request component
http_request:
  useragent: esphome/1.0

font:
  - file:
      type: gfonts
      family: Montserrat
      weight: 700
    size: 30
    id: font_title
    extras: # Add dollar symbol $
      - file: "gfonts://Montserrat"
        glyphs: [$]

  - file:
      type: gfonts
      family: Montserrat
      weight: 400
    size: 30
    id: font_subtitle
    extras: # Add dollar symbol $
      - file: "gfonts://Montserrat"
        glyphs: [$]

  - file:
      type: gfonts
      family: Montserrat
      weight: 400
    size: 14
    id: font_footer

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi
    size: 16
    glyphs:
      # WiFi
      - "\U000F0928" # mdi-wifi-strength-4
      - "\U000F0925" # mdi-wifi-strength-3 
      - "\U000F0922" # mdi-wifi-strength-2
      - "\U000F091F" # mdi-wifi-strength-1
      - "\U000F092B" # mdi-wifi-strength-alert-outline (very weak)
      - "\U000F0450" # mdi-refresh
      # Battery
      - "\U000F0079" # mdi-battery-100
      - "\U000F007A" # mdi-battery-10
      - "\U000F007B" # mdi-battery-20
      - "\U000F007C" # mdi-battery-30
      - "\U000F007D" # mdi-battery-40
      - "\U000F007E" # mdi-battery-50
      - "\U000F007F" # mdi-battery-60
      - "\U000F0080" # mdi-battery-70
      - "\U000F0081" # mdi-battery-80
      - "\U000F0082" # mdi-battery-90
      - "\U000F125E" # mdi-battery-slashed

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_big
    size: 20
    glyphs:
      # All time high icon
      - "\U000F04CE" # star

color:
  - id: colour_white
    hex: "000000"
  - id: colour_black
    hex: "FFFFFF"

spi:
  clk_pin: 4
  mosi_pin: 6

display:
  - platform: waveshare_epaper
    model: 2.90inV2-r2
    cs_pin: 7
    dc_pin: 1
    busy_pin: 3
    reset_pin: 2
    reset_duration: 2ms
    rotation: 270
    full_update_every: 1
    update_interval: never
    id: adam_epaper1
    lambda: |-
      ESP_LOGI("display", ">>> DISPLAY UPDATE <<<     Refresh number: %d", (int)id(display_refreshes).state);

      if (isnan(id(bitcoin_current_price).state)) {
        ESP_LOGD("display", "isnan(id(bitcoin_current_price).state == True. Displaying 'Awaiting data...'");
        it.printf(148, 65, id(font_subtitle), id(colour_black), TextAlign::BASELINE_CENTER, "Awaiting data...");

        if (!isnan(id(display_refreshes).state)) {
          ESP_LOGD("display", "!isnan(id(display_refreshes).state) == True : Displaying 'Refreshes: %d'", (int)id(display_refreshes).state);
          it.printf(148, 85, id(font_footer), id(colour_black), TextAlign::BASELINE_CENTER, "Refreshes: %d", (int)id(display_refreshes).state);
        }
      }
      else {
        ESP_LOGD("display", "isnan(id(bitcoin_current_price).state == False. Displaying Bitcoin price.");
        // Draw main text with formatted price
        ESP_LOGD("bitcoin_current_price", "Formatted Bitcoin price: %s", id(bitcoin_price_formatted).c_str());
        it.printf(it.get_width() / 2, it.get_height()-50, id(font_subtitle), id(colour_black), TextAlign::BOTTOM_CENTER, "Bitcoin: $%s", id(bitcoin_price_formatted).c_str());

        ///////////////////////////////////
        // System status, (last updated time, wifi signal strength, battery status)
        // Width maths is: display width minus wifi icon minus refresh icon minus text width 
        // Show last updated date and time
        it.strftime(it.get_width()-18, it.get_height()-36, id(font_footer), id(colour_black), TextAlign::TOP_RIGHT, "%d%b%y %H:%M", id(homeassistant_time).now());
        // "Refresh" icon
        it.print(it.get_width()-18-105, it.get_height()-36+2, id(font_mdi), id(colour_black), TextAlign::TOP_RIGHT, "\U000F0450");
        
        // Draw WiFi signal strength
        if(id(wifisignal).has_state()) {
          const char* wifi_icon = "\U000F092B";

          if (id(wifisignal).state >= -50) {
              wifi_icon = "\U000F0928";  // Excellent
          } else if (id(wifisignal).state >= -60) {
              wifi_icon = "\U000F0925";  // Good
          } else if (id(wifisignal).state >= -75) {
              wifi_icon = "\U000F0922";  // Fair
          } else if (id(wifisignal).state >= -90) {
              wifi_icon = "\U000F091F";  // Weak
          }

          it.print(it.get_width(), it.get_height()-36, id(font_mdi), id(colour_black), TextAlign::TOP_RIGHT, wifi_icon);
        }

        if (id(battery_percentage).has_state()) {
          // Draw battery icon
          const char* battery_icon = "\U000F125E";  // Default to "Battery slashed" icon
          
          if (id(battery_percentage).state >= 95) {
              battery_icon = "\U000F0079";  // Battery 100
          } else if (id(battery_percentage).state >= 90) {
              battery_icon = "\U000F0082";  // Battery 90
          } else if (id(battery_percentage).state >= 80) {
              battery_icon = "\U000F0081";  // Battery 80
          } else if (id(battery_percentage).state >= 70) {
              battery_icon = "\U000F0080";  // Battery 70
          } else if (id(battery_percentage).state >= 60) {
              battery_icon = "\U000F007F";  // Battery 60
          } else if (id(battery_percentage).state >= 50) {
              battery_icon = "\U000F007E";  // Battery 50
          } else if (id(battery_percentage).state >= 40) {
              battery_icon = "\U000F007D";  // Battery 40
          } else if (id(battery_percentage).state >= 30) {
              battery_icon = "\U000F007C";  // Battery 30
          } else if (id(battery_percentage).state >= 20) {
              battery_icon = "\U000F007B";  // Battery 20
          } else if (id(battery_percentage).state >= 10) {
              battery_icon = "\U000F007A";  // Battery 10
          }

          // Draw battery status text
          it.print(it.get_width(), it.get_height()-18+1, id(font_mdi), id(colour_black), TextAlign::TOP_RIGHT, battery_icon);      
          it.printf(it.get_width()-18, it.get_height()-18, id(font_footer),  id(colour_black), TextAlign::TOP_RIGHT, "%.0f%%", id(battery_percentage).state);

        }
      }